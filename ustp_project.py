# -*- coding: utf-8 -*-
"""USTP-Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xaX7hNxwgqCju-dDsfxOQ5L5y5dndL9K
"""

# Install dependencies
!pip install torch torch-geometric numpy networkx matplotlib

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Set up project structure
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
os.makedirs(f'{project_root}/models', exist_ok=True)
os.makedirs(f'{project_root}/scripts', exist_ok=True)
os.makedirs(f'{project_root}/data', exist_ok=True)
os.makedirs(f'{project_root}/results', exist_ok=True)
os.makedirs(f'{project_root}/report', exist_ok=True)

# Create __init__.py files
with open(f'{project_root}/models/__init__.py', 'w') as f:
    f.write('')
with open(f'{project_root}/scripts/__init__.py', 'w') as f:
    f.write('')

# Save baseline_utsp.py
with open(f'{project_root}/models/baseline_utsp.py', 'w') as f:
    f.write('''import torch
import torch.nn as nn
import torch_geometric.nn as gnn
from torch_geometric.data import Data

class BaselineUTSP(nn.Module):
    def __init__(self, input_dim=2, hidden_dim=128, num_layers=3):
        super(BaselineUTSP, self).__init__()
        self.conv1 = gnn.GCNConv(input_dim, hidden_dim)
        self.convs = nn.ModuleList([gnn.GCNConv(hidden_dim, hidden_dim) for _ in range(num_layers - 1)])
        self.fc = nn.Linear(hidden_dim * 2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = torch.relu(self.conv1(x, edge_index))
        for conv in self.convs:
            x = torch.relu(conv(x, edge_index))
        edge_features = torch.cat([x[edge_index[0]], x[edge_index[1]]], dim=-1)
        edge_scores = self.sigmoid(self.fc(edge_features)).view(-1)
        return edge_scores

def create_graph(coords):
    n = coords.shape[0]
    edge_index = torch.combinations(torch.arange(n), r=2).t()
    edge_index = torch.cat([edge_index, edge_index.flip(0)], dim=1)
    x = torch.tensor(coords, dtype=torch.float)
    return Data(x=x, edge_index=edge_index)
''')

# Save local_search.py (fixed RuntimeError)
with open(f'{project_root}/scripts/local_search.py', 'w') as f:
    f.write('''import numpy as np
import torch

def construct_tour(coords, edge_scores, edge_index):
    n = coords.shape[0]
    tour = [0]
    visited = set([0])
    edge_scores = edge_scores.detach().cpu()
    edge_index = edge_index.detach().cpu()
    while len(visited) < n:
        last_node = tour[-1]
        mask = (edge_index[0] == last_node) | (edge_index[1] == last_node)
        candidates = edge_scores[mask]
        candidate_edges = edge_index[:, mask]
        sorted_indices = np.argsort(-candidates.numpy())
        for idx in sorted_indices:
            u = candidate_edges[0, idx].item()
            v = candidate_edges[1, idx].item()
            next_node = v if u == last_node else u
            if next_node not in visited:
                tour.append(int(next_node))
                visited.add(next_node)
                break
    tour.append(0)
    return np.array(tour)

def two_opt(coords, tour, dist_matrix):
    n = len(tour) - 1
    improved = True
    best_tour = tour.copy()
    best_length = compute_tour_length(coords, best_tour, dist_matrix)
    while improved:
        improved = False
        for i in range(1, n - 1):
            for j in range(i + 2, n):
                new_tour = best_tour.copy()
                new_tour[i:j] = best_tour[i:j][::-1]
                new_length = compute_tour_length(coords, new_tour, dist_matrix)
                if new_length < best_length:
                    best_tour = new_tour
                    best_length = new_length
                    improved = True
    return best_tour, best_length

def compute_tour_length(coords, tour, dist_matrix):
    length = 0
    for i in range(len(tour) - 1):
        length += dist_matrix[tour[i], tour[i + 1]]
    return length
''')

# Save generate_tsp.py
with open(f'{project_root}/scripts/generate_tsp.py', 'w') as f:
    f.write('''import numpy as np
import os

def generate_tsp_instance(n, seed=42):
    np.random.seed(seed)
    coords = np.random.rand(n, 2)
    dist_matrix = np.sqrt(((coords[:, np.newaxis] - coords) ** 2).sum(axis=2))
    return coords, dist_matrix

def save_tsp_instances(sizes=[20, 50], num_instances=2, save_dir="/content/drive/MyDrive/UTSP-Assignment/data"):
    os.makedirs(save_dir, exist_ok=True)
    for n in sizes:
        for i in range(num_instances):
            coords, dist_matrix = generate_tsp_instance(n, seed=i)
            np.save(f"{save_dir}/tsp_{n}_coords_{i}.npy", coords)
            np.save(f"{save_dir}/tsp_{n}_dist_{i}.npy", dist_matrix)

if __name__ == "__main__":
    save_tsp_instances()
''')

# Save train_baseline.py
with open(f'{project_root}/scripts/train_baseline.py', 'w') as f:
    f.write('''import sys
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sys.path.append(project_root)

import torch
import numpy as np
from models.baseline_utsp import BaselineUTSP, create_graph
from scripts.local_search import construct_tour, two_opt, compute_tour_length

def surrogate_loss(edge_scores, edge_index, dist_matrix, coords):
    with torch.no_grad():
        tour = construct_tour(coords, edge_scores, edge_index)
        length = compute_tour_length(coords, tour, dist_matrix)
    return torch.tensor(length, dtype=torch.float)

def train_baseline(size=20, num_epochs=50, lr=0.001, data_dir="/content/drive/MyDrive/UTSP-Assignment/data"):
    model = BaselineUTSP()
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    coords = np.load(f"{data_dir}/tsp_{size}_coords_0.npy")
    dist_matrix = np.load(f"{data_dir}/tsp_{size}_dist_0.npy")
    data = create_graph(coords)

    for epoch in range(num_epochs):
        model.train()
        optimizer.zero_grad()
        edge_scores = model(data)
        loss = surrogate_loss(edge_scores, data.edge_index, dist_matrix, coords)
        loss.backward()
        optimizer.step()
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss.item()}")
    os.makedirs("/content/drive/MyDrive/UTSP-Assignment/results", exist_ok=True)
    torch.save(model.state_dict(), f"/content/drive/MyDrive/UTSP-Assignment/results/baseline_utsp_{size}.pth")
    return model

if __name__ == "__main__":
    train_baseline()
''')

# Save evaluate.py (generates visuals)
with open(f'{project_root}/scripts/evaluate.py', 'w') as f:
    f.write('''import sys
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sys.path.append(project_root)

import torch
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from models.baseline_utsp import BaselineUTSP, create_graph
from scripts.local_search import construct_tour, two_opt, compute_tour_length

def evaluate_model(model, coords, dist_matrix, model_name, size, results_dir):
    data = create_graph(coords)
    model.eval()
    with torch.no_grad():
        edge_scores = model(data)
    tour = construct_tour(coords, edge_scores, data.edge_index)
    tour, length = two_opt(coords, tour, dist_matrix)

    # Plot TSP tour
    G = nx.Graph()
    for i in range(len(coords)):
        G.add_node(i, pos=coords[i])
    for i in range(len(tour) - 1):
        G.add_edge(tour[i], tour[i + 1])
    pos = nx.get_node_attributes(G, 'pos')
    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, node_color='blue', node_size=50, edge_color='red')
    plt.title(f"{model_name} Tour (n={size}, Length={length:.2f})")
    plt.savefig(f"{results_dir}/{model_name}_tour_{size}.png")
    plt.close()
    return length

def main():
    sizes = [20, 50]
    results_dir = "/content/drive/MyDrive/UTSP-Assignment/results"
    data_dir = "/content/drive/MyDrive/UTSP-Assignment/data"
    baseline_lengths = []

    for size in sizes:
        coords = np.load(f"{data_dir}/tsp_{size}_coords_0.npy")
        dist_matrix = np.load(f"{data_dir}/tsp_{size}_dist_0.npy")
        model = BaselineUTSP()
        model.load_state_dict(torch.load(f"{results_dir}/baseline_utsp_{size}.pth"))

        length = evaluate_model(model, coords, dist_matrix, "baseline", size, results_dir)
        baseline_lengths.append(length)

    # Plot comparison chart
    plt.figure(figsize=(8, 6))
    plt.plot(sizes, baseline_lengths, marker='o', label='Baseline')
    plt.xlabel('TSP Size (n)')
    plt.ylabel('Tour Length')
    plt.title('Baseline: Tour Length vs TSP Size')
    plt.legend()
    plt.grid(True)
    plt.savefig(f"{results_dir}/length_comparison.png")
    plt.close()

if __name__ == "__main__":
    main()
''')

# Generate TSP instances
!python {project_root}/scripts/generate_tsp.py

# Train baseline model for sizes 20, 50
!python {project_root}/scripts/train_baseline.py --size 20
!python {project_root}/scripts/train_baseline.py --size 50

# Evaluate and generate visuals
!python {project_root}/scripts/evaluate.py

# Install dependencies
!pip install torch torch-geometric numpy networkx matplotlib

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

# Set up project structure
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
os.makedirs(f'{project_root}/models', exist_ok=True)
os.makedirs(f'{project_root}/scripts', exist_ok=True)
os.makedirs(f'{project_root}/data', exist_ok=True)
os.makedirs(f'{project_root}/results', exist_ok=True)
os.makedirs(f'{project_root}/report', exist_ok=True)

# Create __init__.py files
with open(f'{project_root}/models/__init__.py', 'w') as f:
    f.write('')
with open(f'{project_root}/scripts/__init__.py', 'w') as f:
    f.write('')

# Save baseline_utsp.py
with open(f'{project_root}/models/baseline_utsp.py', 'w') as f:
    f.write('''import torch
import torch.nn as nn
import torch_geometric.nn as gnn
from torch_geometric.data import Data

class BaselineUTSP(nn.Module):
    def __init__(self, input_dim=2, hidden_dim=128, num_layers=3):
        super(BaselineUTSP, self).__init__()
        self.conv1 = gnn.GCNConv(input_dim, hidden_dim)
        self.convs = nn.ModuleList([gnn.GCNConv(hidden_dim, hidden_dim) for _ in range(num_layers - 1)])
        self.fc = nn.Linear(hidden_dim * 2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = torch.relu(self.conv1(x, edge_index))
        for conv in self.convs:
            x = torch.relu(conv(x, edge_index))
        edge_features = torch.cat([x[edge_index[0]], x[edge_index[1]]], dim=-1)
        edge_scores = self.sigmoid(self.fc(edge_features)).view(-1)
        return edge_scores

def create_graph(coords):
    n = coords.shape[0]
    edge_index = torch.combinations(torch.arange(n), r=2).t()
    edge_index = torch.cat([edge_index, edge_index.flip(0)], dim=1)
    x = torch.tensor(coords, dtype=torch.float)
    return Data(x=x, edge_index=edge_index)
''')

# Save local_search.py
with open(f'{project_root}/scripts/local_search.py', 'w') as f:
    f.write('''import numpy as np
import torch

def construct_tour(coords, edge_scores, edge_index):
    n = coords.shape[0]
    tour = [0]
    visited = set([0])
    edge_scores = edge_scores.detach().cpu()
    edge_index = edge_index.detach().cpu()
    while len(visited) < n:
        last_node = tour[-1]
        mask = (edge_index[0] == last_node) | (edge_index[1] == last_node)
        candidates = edge_scores[mask]
        candidate_edges = edge_index[:, mask]
        sorted_indices = np.argsort(-candidates.numpy())
        for idx in sorted_indices:
            u = candidate_edges[0, idx].item()
            v = candidate_edges[1, idx].item()
            next_node = v if u == last_node else u
            if next_node not in visited:
                tour.append(int(next_node))
                visited.add(next_node)
                break
    tour.append(0)
    return np.array(tour)

def two_opt(coords, tour, dist_matrix):
    n = len(tour) - 1
    improved = True
    best_tour = tour.copy()
    best_length = compute_tour_length(coords, best_tour, dist_matrix)
    while improved:
        improved = False
        for i in range(1, n - 1):
            for j in range(i + 2, n):
                new_tour = best_tour.copy()
                new_tour[i:j] = best_tour[i:j][::-1]
                new_length = compute_tour_length(coords, new_tour, dist_matrix)
                if new_length < best_length:
                    best_tour = new_tour
                    best_length = new_length
                    improved = True
    return best_tour, best_length

def compute_tour_length(coords, tour, dist_matrix):
    length = 0
    for i in range(len(tour) - 1):
        length += dist_matrix[tour[i], tour[i + 1]]
    return length
''')

# Save generate_tsp.py
with open(f'{project_root}/scripts/generate_tsp.py', 'w') as f:
    f.write('''import numpy as np
import os

def generate_tsp_instance(n, seed=42):
    np.random.seed(seed)
    coords = np.random.rand(n, 2)
    dist_matrix = np.sqrt(((coords[:, np.newaxis] - coords) ** 2).sum(axis=2))
    return coords, dist_matrix

def save_tsp_instances(sizes=[20, 50], num_instances=2, save_dir="/content/drive/MyDrive/UTSP-Assignment/data"):
    os.makedirs(save_dir, exist_ok=True)
    for n in sizes:
        for i in range(num_instances):
            coords, dist_matrix = generate_tsp_instance(n, seed=i)
            np.save(f"{save_dir}/tsp_{n}_coords_{i}.npy", coords)
            np.save(f"{save_dir}/tsp_{n}_dist_{i}.npy", dist_matrix)

if __name__ == "__main__":
    save_tsp_instances()
''')

# Save train_baseline.py
with open(f'{project_root}/scripts/train_baseline.py', 'w') as f:
    f.write('''import sys
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sys.path.append(project_root)

import torch
import numpy as np
from models.baseline_utsp import BaselineUTSP, create_graph
from scripts.local_search import construct_tour, two_opt, compute_tour_length

def surrogate_loss(edge_scores, edge_index, dist_matrix, coords):
    edge_weights = torch.tensor(dist_matrix[edge_index[0], edge_index[1]], dtype=torch.float, device=edge_scores.device)
    loss = torch.sum(edge_scores * edge_weights)
    return loss

def train_baseline(size=20, num_epochs=50, lr=0.001, data_dir="/content/drive/MyDrive/UTSP-Assignment/data"):
    model = BaselineUTSP()
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model.to(device)
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    coords = np.load(f"{data_dir}/tsp_{size}_coords_0.npy")
    dist_matrix = np.load(f"{data_dir}/tsp_{size}_dist_0.npy")
    data = create_graph(coords)
    data.x = data.x.to(device)
    data.edge_index = data.edge_index.to(device)

    losses = []
    for epoch in range(num_epochs):
        model.train()
        optimizer.zero_grad()
        edge_scores = model(data)
        loss = surrogate_loss(edge_scores, data.edge_index, dist_matrix, coords)
        loss.backward()
        optimizer.step()
        losses.append(loss.item())
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss.item()}")

    # Plot training loss
    import matplotlib.pyplot as plt
    plt.figure(figsize=(8, 6))
    plt.plot(range(num_epochs), losses, marker='o', color='blue')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.title(f'Training Loss for TSP Size n={size}')
    plt.grid(True)
    plt.savefig(f"/content/drive/MyDrive/UTSP-Assignment/results/training_loss_{size}.png")
    plt.close()

    os.makedirs("/content/drive/MyDrive/UTSP-Assignment/results", exist_ok=True)
    torch.save(model.state_dict(), f"/content/drive/MyDrive/UTSP-Assignment/results/baseline_utsp_{size}.pth")
    return model

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--size', type=int, default=20)
    args = parser.parse_args()
    train_baseline(size=args.size)
''')

# Save evaluate.py (fixed SyntaxError)
with open(f'{project_root}/scripts/evaluate.py', 'w') as f:
    f.write('''import sys
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sys.path.append(project_root)

import torch
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from models.baseline_utsp import BaselineUTSP, create_graph
from scripts.local_search import construct_tour, two_opt, compute_tour_length

def evaluate_model(model, coords, dist_matrix, model_name, size, results_dir):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    data = create_graph(coords)
    data.x = data.x.to(device)
    data.edge_index = data.edge_index.to(device)
    model.eval()
    with torch.no_grad():
        edge_scores = model(data)
    tour = construct_tour(coords, edge_scores, data.edge_index)
    tour, length = two_opt(coords, tour, dist_matrix)

    # Plot TSP tour
    G = nx.Graph()
    for i in range(len(coords)):
        G.add_node(i, pos=coords[i])
    for i in range(len(tour) - 1):
        G.add_edge(tour[i], tour[i + 1])
    pos = nx.get_node_attributes(G, 'pos')
    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, node_color='blue', node_size=50, edge_color='red')
    plt.title(f"{model_name} Tour (n={size}, Length={length:.2f})")
    plt.savefig(f"{results_dir}/{model_name}_tour_{size}.png")
    plt.close()
    return length

def main():
    sizes = [20, 50]
    results_dir = "/content/drive/MyDrive/UTSP-Assignment/results"
    data_dir = "/content/drive/MyDrive/UTSP-Assignment/data"
    baseline_lengths = []

    for size in sizes:
        coords = np.load(f"{data_dir}/tsp_{size}_coords_0.npy")
        dist_matrix = np.load(f"{data_dir}/tsp_{size}_dist_0.npy")
        model = BaselineUTSP()
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        model.to(device)
        model.load_state_dict(torch.load(f"{results_dir}/baseline_utsp_{size}.pth", map_location=device))
        length = evaluate_model(model, coords, dist_matrix, "baseline", size, results_dir)
        baseline_lengths.append(length)

    # Plot comparison chart
    plt.figure(figsize=(8, 6))
    plt.plot(sizes, baseline_lengths, marker='o', label='Baseline', color='green')
    plt.xlabel('TSP Size (n)')
    plt.ylabel('Tour Length')
    plt.title('Baseline: Tour Length vs TSP Size')
    plt.legend()
    plt.grid(True)
    plt.savefig(f"{results_dir}/length_comparison.png")
    plt.close()

if __name__ == "__main__":
    main()
''')

# Generate TSP instances
!python {project_root}/scripts/generate_tsp.py

# Train baseline model for sizes 20, 50
!python {project_root}/scripts/train_baseline.py --size 20
!python {project_root}/scripts/train_baseline.py --size 50

# Evaluate and generate visuals
!python {project_root}/scripts/evaluate.py

# Display visuals in Colab
from IPython.display import Image, display
for size in [20, 50]:
    display(Image(f'/content/drive/MyDrive/UTSP-Assignment/results/baseline_tour_{size}.png'))
    display(Image(f'/content/drive/MyDrive/UTSP-Assignment/results/training_loss_{size}.png'))
display(Image(f'/content/drive/MyDrive/UTSP-Assignment/results/length_comparison.png'))

# Section 1: Create Modified UTSP Model with GAT
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'

# Create modified_utsp.py

import torch
import torch.nn as nn
import torch_geometric.nn as gnn
from torch_geometric.data import Data

class ModifiedUTSP(nn.Module):
    def __init__(self, input_dim=2, hidden_dim=128, num_layers=3, heads=4):
        super(ModifiedUTSP, self).__init__()
        self.conv1 = gnn.GATConv(input_dim, hidden_dim, heads=heads)
        self.convs = nn.ModuleList([gnn.GATConv(hidden_dim * heads, hidden_dim, heads=heads) for _ in range(num_layers - 1)])
        self.fc = nn.Linear(hidden_dim * heads * 2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = torch.relu(self.conv1(x, edge_index))
        for conv in self.convs:
            x = torch.relu(conv(x, edge_index))
        edge_features = torch.cat([x[edge_index[0]], x[edge_index[1]]], dim=-1)
        edge_scores = self.sigmoid(self.fc(edge_features)).view(-1)
        return edge_scores

def create_graph(coords):
    n = coords.shape[0]
    edge_index = torch.combinations(torch.arange(n), r=2).t()
    edge_index = torch.cat([edge_index, edge_index.flip(0)], dim=1)
    x = torch.tensor(coords, dtype=torch.float)
    return Data(x=x, edge_index=edge_index)

# Create modified_utsp.py with GAT-based model
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'

with open(f'{project_root}/models/modified_utsp.py', 'w') as f:
    f.write('''import torch
import torch.nn as nn
import torch_geometric.nn as gnn
from torch_geometric.data import Data

class ModifiedUTSP(nn.Module):
    def __init__(self, input_dim=2, hidden_dim=128, num_layers=3, heads=4):
        super(ModifiedUTSP, self).__init__()
        self.conv1 = gnn.GATConv(input_dim, hidden_dim, heads=heads)
        self.convs = nn.ModuleList([gnn.GATConv(hidden_dim * heads, hidden_dim, heads=heads) for _ in range(num_layers - 1)])
        self.fc = nn.Linear(hidden_dim * heads * 2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = torch.relu(self.conv1(x, edge_index))
        for conv in self.convs:
            x = torch.relu(conv(x, edge_index))
        edge_features = torch.cat([x[edge_index[0]], x[edge_index[1]]], dim=-1)
        edge_scores = self.sigmoid(self.fc(edge_features)).view(-1)
        return edge_scores

def create_graph(coords):
    n = coords.shape[0]
    edge_index = torch.combinations(torch.arange(n), r=2).t()
    edge_index = torch.cat([edge_index, edge_index.flip(0)], dim=1)
    x = torch.tensor(coords, dtype=torch.float)
    return Data(x=x, edge_index=edge_index)
''')

# Update train_baseline.py to support both baseline and modified models
with open(f'{project_root}/scripts/train_baseline.py', 'w') as f:
    f.write('''import sys
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sys.path.append(project_root)

import torch
import numpy as np
import matplotlib.pyplot as plt
from models.baseline_utsp import BaselineUTSP, create_graph
from models.modified_utsp import ModifiedUTSP
from scripts.local_search import construct_tour, two_opt, compute_tour_length

def surrogate_loss(edge_scores, edge_index, dist_matrix, coords):
    edge_weights = torch.tensor(dist_matrix[edge_index[0], edge_index[1]], dtype=torch.float, device=edge_scores.device)
    loss = torch.sum(edge_scores * edge_weights)
    return loss

def train_model(model_type='baseline', size=20, num_epochs=50, lr=0.001, data_dir="/content/drive/MyDrive/UTSP-Assignment/data"):
    if model_type == 'baseline':
        model = BaselineUTSP()
    else:
        model = ModifiedUTSP()

    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model.to(device)
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    coords = np.load(f"{data_dir}/tsp_{size}_coords_0.npy")
    dist_matrix = np.load(f"{data_dir}/tsp_{size}_dist_0.npy")
    data = create_graph(coords)
    data.x = data.x.to(device)
    data.edge_index = data.edge_index.to(device)

    losses = []
    for epoch in range(num_epochs):
        model.train()
        optimizer.zero_grad()
        edge_scores = model(data)
        loss = surrogate_loss(edge_scores, data.edge_index, dist_matrix, coords)
        loss.backward()
        optimizer.step()
        losses.append(loss.item())
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss.item()}")

    plt.figure(figsize=(8, 6))
    plt.plot(range(num_epochs), losses, marker='o', color='blue')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.title(f'Training Loss for {model_type} (n={size})')
    plt.grid(True)
    plt.savefig(f"/content/drive/MyDrive/UTSP-Assignment/results/training_loss_{model_type}_{size}.png")
    plt.close()

    os.makedirs("/content/drive/MyDrive/UTSP-Assignment/results", exist_ok=True)
    torch.save(model.state_dict(), f"/content/drive/MyDrive/UTSP-Assignment/results/{model_type}_utsp_{size}.pth")
    return model

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--model', type=str, default='baseline', choices=['baseline', 'modified'])
    parser.add_argument('--size', type=int, default=20)
    args = parser.parse_args()
    train_model(model_type=args.model, size=args.size)
''')

# Update generate_tsp.py for larger sizes and run it
with open(f'{project_root}/scripts/generate_tsp.py', 'w') as f:
    f.write('''import numpy as np
import os

def generate_tsp_instance(n, seed=42):
    np.random.seed(seed)
    coords = np.random.rand(n, 2)
    dist_matrix = np.sqrt(((coords[:, np.newaxis] - coords) ** 2).sum(axis=2))
    return coords, dist_matrix

def save_tsp_instances(sizes=[20, 50, 100, 200, 500], num_instances=10, save_dir="/content/drive/MyDrive/UTSP-Assignment/data"):
    os.makedirs(save_dir, exist_ok=True)
    for n in sizes:
        for i in range(num_instances):
            coords, dist_matrix = generate_tsp_instance(n, seed=i)
            np.save(f"{save_dir}/tsp_{n}_coords_{i}.npy", coords)
            np.save(f"{save_dir}/tsp_{n}_dist_{i}.npy", dist_matrix)

if __name__ == "__main__":
    save_tsp_instances()
''')

!python {project_root}/scripts/generate_tsp.py

# Update evaluate.py for comprehensive comparison
with open(f'{project_root}/scripts/evaluate.py', 'w') as f:
    f.write('''import sys
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sys.path.append(project_root)

import torch
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from models.baseline_utsp import BaselineUTSP, create_graph
from models.modified_utsp import ModifiedUTSP
from scripts.local_search import construct_tour, two_opt, compute_tour_length

def evaluate_model(model, coords, dist_matrix, model_name, size, instance_idx, results_dir):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    data = create_graph(coords)
    data.x = data.x.to(device)
    data.edge_index = data.edge_index.to(device)
    model.eval()
    with torch.no_grad():
        edge_scores = model(data)
    tour = construct_tour(coords, edge_scores, data.edge_index)
    tour, length = two_opt(coords, tour, dist_matrix)

    if instance_idx == 0:
        G = nx.Graph()
        for i in range(len(coords)):
            G.add_node(i, pos=coords[i])
        for i in range(len(tour) - 1):
            G.add_edge(tour[i], tour[i + 1])
        pos = nx.get_node_attributes(G, 'pos')
        plt.figure(figsize=(8, 6))
        nx.draw(G, pos, node_color='blue', node_size=50, edge_color='red')
        plt.title(f"{model_name} Tour (n={size}, Length={length:.2f})")
        plt.savefig(f"{results_dir}/{model_name}_tour_{size}.png")
        plt.close()

    return length

def main():
    sizes = [20, 50, 100, 200, 500]
    num_instances = 10
    results_dir = "/content/drive/MyDrive/UTSP-Assignment/results"
    data_dir = "/content/drive/MyDrive/UTSP-Assignment/data"
    baseline_lengths = {size: [] for size in sizes}
    modified_lengths = {size: [] for size in sizes}

    for size in sizes:
        for i in range(num_instances):
            coords = np.load(f"{data_dir}/tsp_{size}_coords_{i}.npy")
            dist_matrix = np.load(f"{data_dir}/tsp_{size}_dist_{i}.npy")

            baseline_model = BaselineUTSP()
            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
            baseline_model.to(device)
            baseline_model.load_state_dict(torch.load(f"{results_dir}/baseline_utsp_{size}.pth", map_location=device))
            baseline_length = evaluate_model(baseline_model, coords, dist_matrix, "baseline", size, i, results_dir)
            baseline_lengths[size].append(baseline_length)

            modified_model = ModifiedUTSP()
            modified_model.to(device)
            modified_model.load_state_dict(torch.load(f"{results_dir}/modified_utsp_{size}.pth", map_location=device))
            modified_length = evaluate_model(modified_model, coords, dist_matrix, "modified", size, i, results_dir)
            modified_lengths[size].append(modified_length)

    baseline_avg = [np.mean(baseline_lengths[size]) for size in sizes]
    modified_avg = [np.mean(modified_lengths[size]) for size in sizes]

    plt.figure(figsize=(10, 6))
    x = np.arange(len(sizes))
    width = 0.35
    plt.bar(x - width/2, baseline_avg, width, label='Baseline (GCN)', color='green')
    plt.bar(x + width/2, modified_avg, width, label='Modified (GAT)', color='orange')
    plt.xlabel('TSP Size (n)')
    plt.ylabel('Average Tour Length')
    plt.title('Tour Length Comparison: Baseline vs Modified')
    plt.xticks(x, sizes)
    plt.legend()
    plt.grid(True)
    plt.savefig(f"{results_dir}/length_comparison.png")
    plt.close()

if __name__ == "__main__":
    main()
''')

# Train baseline and modified models for all sizes
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sizes = [20, 50, 100, 200, 500]

for size in sizes:
    print(f"Training baseline model for size {size}")
    !python {project_root}/scripts/train_baseline.py --model baseline --size {size}

for size in sizes:
    print(f"Training modified model for size {size}")
    !python {project_root}/scripts/train_baseline.py --model modified --size {size}

# Evaluate models and display visuals
from IPython.display import Image, display
project_root = '/content/drive/MyDrive/UTSP-Assignment'
sizes = [20, 50, 100]

!python {project_root}/scripts/evaluate.py

for size in sizes:
    print(f"Results for TSP size {size}")
    display(Image(f'{project_root}/results/baseline_tour_{size}.png'))
    display(Image(f'{project_root}/results/modified_tour_{size}.png'))
    display(Image(f'{project_root}/results/training_loss_baseline_{size}.png'))
    display(Image(f'{project_root}/results/training_loss_modified_{size}.png'))
display(Image(f'{project_root}/results/length_comparison.png'))

# Create LaTeX report template
with open(f'{project_root}/report/experimental_report.tex', 'w') as f:
    f.write('''\\documentclass[a4paper,12pt]{article}
\\usepackage{amsmath}
\\usepackage{graphicx}
\\usepackage{natbib}
\\usepackage{geometry}
\\geometry{margin=1in}
\\usepackage[T1]{fontenc}
\\usepackage{times}

\\begin{document}

\\title{Unsupervised Travelling Salesman Problem: Implementation and Enhancements}
\\author{Your Name}
\\date{June 2025}
\\maketitle

\\begin{abstract}
This report presents the implementation and modification of the Unsupervised Travelling Salesman Problem (UTSP) framework, utilizing Graph Neural Networks (GNNs) to solve TSP instances without labelled data. We reimplement the baseline UTSP model and introduce a modified version using a Graph Attention Network (GAT). Experimental comparisons across TSP sizes (n=20, 50, 100, 200, 500) demonstrate the performance of both models in terms of tour length and computational efficiency.
\\end{abstract}

\\section{Introduction}
The Travelling Salesman Problem (TSP) is a classic combinatorial optimization problem. The UTSP framework \\citep{utsp-paper} leverages unsupervised learning and GNNs to predict edge probabilities, followed by local search heuristics. This project reimplements the baseline UTSP and introduces a GAT-based modification.

\\section{Implementation Details}
\\subsection{Baseline UTSP}
The baseline model uses GCNConv layers with a surrogate loss based on edge weights.

\\subsection{Modified UTSP}
The modified model replaces GCNConv with GATConv, incorporating attention mechanisms to improve edge probability predictions.

\\section{Experimental Setup}
We evaluate both models on TSP instances of sizes n=20, 50, 100, 200, and 500, with 10 instances per size. Metrics include tour length and computation time.

\\section{Results}
Results are visualized through tour plots, training loss curves, and a comparison chart of average tour lengths.

\\section{Challenges}
Challenges include memory limitations for large TSP instances and hyperparameter tuning.

\\section{Conclusion}
The modified GAT-based model shows potential improvements over the baseline, particularly for larger instances.

\\bibliographystyle{plain}
\\bibliography{references}

\\end{document}
''')

# Create README.md for GitHub repository
with open(f'{project_root}/README.md', 'w') as f:
    f.write('''# Unsupervised Travelling Salesman Problem (UTSP) Project

## Overview
This repository contains the implementation of the UTSP framework for solving the Travelling Salesman Problem using unsupervised learning and Graph Neural Networks (GNNs). It includes a baseline model (GCN-based) and a modified model (GAT-based), with scripts for training, evaluation, and visualization.

## Project Structure''')


## Project Structure

!git clone https://github.com/YoshitaB/UTSP-Project.git

!ls -R /content/drive/MyDrive/UTSP-Assignment

# Commented out IPython magic to ensure Python compatibility.
# Configure Git in Colab
import os
project_root = '/content/drive/MyDrive/UTSP-Assignment'

# Navigate to project directory
# %cd {project_root}

# Initialize Git repository
!git init

# Configure Git user
!git config --global user.email "banerjeeyoshita2020@gmail.com"
!git config --global user.name "YoshitaB"

# Add all files
!git add .

# Commit changes
!git commit -m "Initial commit of UTSP project with baseline and modified models"

# Add remote repository (replace <token> with your personal access token)
# Example URL: https://<token>@github.com/YoshitaB/UTSP-Project.git
token = input("Enter your GitHub personal access token: ")
repo_url = f"https://{token}@github.com/YoshitaB/UTSP-Project.git"
!git remote add origin {repo_url}

# Push to GitHub
!git push -u origin main

# Remove token from memory for security
token = None

!python scripts/generate_tsp.py

!python scripts/train_baseline.py --model baseline --size 20
!python scripts/train_baseline.py --model modified --size 20

!python scripts/evaluate.py